import java_cup.runtime.*; // defines the Symbol class

// The generated scanner will return a Symbol for each token that it finds.
// A Symbol contains an Object field named value; that field will be of type
// TokenVal, defined below.
//
// A TokenVal object contains the line number on which the token occurs as
// well as the number of the character on that line that starts the token.
// Some tokens (e.g., literals) also include the value of the token.

class TokenVal {
 // fields
    int linenum;
    int charnum;
 // constructor
    TokenVal(int l, int c) {
        linenum = l;
		charnum = c;
    }
}

class IntLitTokenVal extends TokenVal {
    int intVal;

    IntLitTokenVal(int l, int c, int val) {
        super(l, c);
		intVal = val;
    }
}

class StringLitTokenVal extends TokenVal {
	String stringVal;

	StringLitTokenVal(int l, int c, String val) {
		super(l, c);
		stringVal = val;
	}
}


// The following class is used to keep track of the character number at which
// the current token starts on its line.
class CharNum {
  static int num=1;
}
%%

DIGIT=		[0-9]
WHITESPACE=	[\ \t\n]
NEWLINE=    (\r|\n|\r\n)

%state STRING COMMENT NORMAL

%init{
	yybegin( NORMAL )
%init}

// The next 3 lines are included so that we can use the generated scanner
// with java CUP (the Java parser generator)
%implements java_cup.runtime.Scanner
%function next_token
%type java_cup.runtime.Symbol

// Tell JLex what to do on end-of-file
%eofval{
return new Symbol(sym.EOF);
%eofval}

// Turn on line counting
%line

%%

<NORMAL> {
	// count char num on line
	{WHITESPACE}+ { 
		CharNum.num += yytext().length();
	}

	// reset charnum after newline
	{NEWLINE} {
		CharNum.num = 0;
	}

	// start string mode - other version below
	//	\" {
	//		yybegin( STRING );
	//	}

	// start comment mode
	"/*" {
		charNum.num = 0;
		yybegin ( COMMENT );
	}

	// reserved: String
	String {
		Symbol S = new Symbol(sym.STRING, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 6;
		return s;
	}

	// reserved: System.out.println
	System.out.println {
		Symbol S = new Symbol(sym.PRINT, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 18;
		return s;
	}

	// reserved: boolean
	boolean {
		Symbol S = new Symbol(sym.BOOLEAN, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 7;
		return s;
	}

	// reserved: class
	class {
		Symbol S = new Symbol(sym.CLASS, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 5;
		return s;
	}

	// reserved: do
	do {
		Symbol S = new Symbol(sym.DO, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 2;
		return s;
	}

	// reserved: else
	else {
		Symbol S = new Symbol(sym.ELSE, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 4;
		return s;
	}

	// reserved: false
	false {
		Symbol S = new Symbol(sym.FALSE, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 5;
		return s;
	}

	// reserved: if
	if {
		Symbol S = new Symbol(sym.IF, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 2;
		return s;
	}

	// reserved: int
	int {
		Symbol S = new Symbol(sym.INT, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 3;
		return s;
	}

	// reserved: public
	public {
		Symbol S = new Symbol(sym.PUBLIC, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 6;
		return s;
	}

	// reserved: return
	return {
		Symbol S = new Symbol(sym.RETURN, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 6;
		return s;
	}

	// reserved: static
	static {
		Symbol S = new Symbol(sym.STATIC, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 6;
		return s;
	}

	// reserved: true
	true {
		Symbol S = new Symbol(sym.TRUE, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 4;
		return s;
	}

	// reserved: void
	void {
		Symbol S = new Symbol(sym.VOID, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 4;
		return s;
	}

	// reserved: while
	while {
		Symbol S = new Symbol(sym.WHILE, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 5;
		return s;
	}

	// !!!
	// reserved: case
	case {
		Symbol S = new Symbol(sym.IF, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 4;
		return s;
	}

	// !!!
	// reserved: switch
	switch {
		Symbol S = new Symbol(sym.IF, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 6;
		return s;
	}

	// !!!
	// reserved: default
	default {
		Symbol S = new Symbol(sym.ELSE, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 7;
		return s;
	}

	// symbol: {
	"{" {
		Symbol S = new Symbol(sym.LCURLY, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: }
	"}" {
		Symbol S = new Symbol(sym.RCURLY, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: (
	"(" {
		Symbol S = new Symbol(sym.LPAREN, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: )
	")" {
		Symbol S = new Symbol(sym.RPAREN, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: ,
	, {
		Symbol S = new Symbol(sym.COMMA, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: =
	= {
		Symbol S = new Symbol(sym.ASSIGN, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: ;
	; {
		Symbol S = new Symbol(sym.SEMICOLON, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: +
	"+" {
		Symbol S = new Symbol(sym.PLUS, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: -
	- {
		Symbol S = new Symbol(sym.MINUS, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: *
	"*" {
		Symbol S = new Symbol(sym.TIMES, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: /
	/ {
		Symbol S = new Symbol(sym.DIVIDE, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: !
	! {
		Symbol S = new Symbol(sym.NOT, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: &&
	&& {
		Symbol S = new Symbol(sym.AND, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 2;
		return s;
	}

	// symbol: ||
	"||" {
		Symbol S = new Symbol(sym.OR, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 2;
		return s;
	}

	// symbol: ==
	== {
		Symbol S = new Symbol(sym.EQUALS, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 2;
		return s;
	}

	// symbol: !=
	!= {
		Symbol S = new Symbol(sym.NOTEQUALS, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 2;
		return s;
	}

	// symbol: <
	< {
		Symbol S = new Symbol(sym.LESS, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: >
	> {
		Symbol S = new Symbol(sym.GREATER, new TokenVal(yyline+1), CharNum.num);
		CharNum.num++;
		return s;
	}

	// symbol: <=
	<= {
		Symbol S = new Symbol(sym.LESSEQ, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 2;
		return s;
	}

	// symbol: >=
	>= {
		Symbol S = new Symbol(sym.GREATEREQ, new TokenVal(yyline+1), CharNum.num);
		CharNum.num += 2;
		return s;
	}

	// stringliteral
	"".*?"(?<!\\")" {
		String str = yytext().substring(1, yytext().length() - 1);
		Symbol S = new Symbol(sym.STRINGLITERAL, new StringLitTokenVal(yyline+1, CharNum.num, str))
		CharNum.num += yytext().length;
		return s;
	}

	// intliteral
	{DIGIT}+ {
		// TODO: check for overflow	
		int val = new Integer(yytext()).intValue();
		Symbol S = new Symbol(sym.INTLITERAL, new IntLitTokenVal(yyline+1, CharNum.num, val));
		CharNum.num += yytext().length();
		return s;
	}
	    
	. {
		Errors.fatal(yyline+1, CharNum.num, "ignoring illegal character: " + yytext());
	    CharNum.num++;
	}
}

<STRING> {
	// !!! "string" -> "string" and not (") (string) (")
	// sonst: " (ALLES) bis " ohne: \" + nimm den 1. besten
	\" {
		yybegin( NORMAL );
	}
}

<COMMENT> {
	"*/" {
		yybegin( NORMAL );
	}

	{NEWLINE} {}
	. {}
}
